// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 2.0.50727.1433
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------

namespace PoyRunner.PoyService {
    
    
    /// <remarks/>
    /// <remarks>
///Service for running poy on glenn osc super computer
///</remarks>
    [System.Web.Services.WebServiceBinding(Name="PoyServiceSoap", Namespace="supramap")]
    [System.Diagnostics.DebuggerStepThroughAttribute()]
    [System.ComponentModel.DesignerCategoryAttribute("code")]
    public partial class PoyService : System.Web.Services.Protocols.SoapHttpClientProtocol {
        
        private System.Threading.SendOrPostCallback InitOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback AddTextFileOperationCompleted;
        
        private System.Threading.SendOrPostCallback SubmitPoyOperationCompleted;
        
        private System.Threading.SendOrPostCallback IsDoneYetOperationCompleted;
        
        private System.Threading.SendOrPostCallback GetFileOperationCompleted;
        
        public PoyService() {
            this.Url = "http://glenn-webservice.bmi.ohio-state.edu/PoyService.asmx";
        }
        
        public PoyService(string url) {
            this.Url = url;
        }
        
        public event InitCompletedEventHandler InitCompleted;
        
        public event AddFileCompletedEventHandler AddFileCompleted;
        
        public event AddTextFileCompletedEventHandler AddTextFileCompleted;
        
        public event SubmitPoyCompletedEventHandler SubmitPoyCompleted;
        
        public event IsDoneYetCompletedEventHandler IsDoneYetCompleted;
        
        public event GetFileCompletedEventHandler GetFileCompleted;
        
        /// <remarks>
///The 'Init' method basically creates a directory on the super computer it returns a token that must be 
///          used on all subsequent method calls as the jobId parameter.Note this token will only work with the ipaddress that was used to 
///          call this method. Note it is not enforced but it highly encouraged to use this method over https.
///          a pass prase to use this web service please vist http://glenn-service.bmi.ohio-state.edu/Welcome.aspx
///</remarks>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("supramap/Init", RequestNamespace="supramap", ResponseNamespace="supramap", ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped, Use=System.Web.Services.Description.SoapBindingUse.Literal)]
        public int Init(string passPhase) {
            object[] results = this.Invoke("Init", new object[] {
                        passPhase});
            return ((int)(results[0]));
        }
        
        public System.IAsyncResult BeginInit(string passPhase, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("Init", new object[] {
                        passPhase}, callback, asyncState);
        }
        
        public int EndInit(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((int)(results[0]));
        }
        
        public void InitAsync(string passPhase) {
            this.InitAsync(passPhase, null);
        }
        
        public void InitAsync(string passPhase, object userState) {
            if ((this.InitOperationCompleted == null)) {
                this.InitOperationCompleted = new System.Threading.SendOrPostCallback(this.OnInitCompleted);
            }
            this.InvokeAsync("Init", new object[] {
                        passPhase}, this.InitOperationCompleted, userState);
        }
        
        private void OnInitCompleted(object arg) {
            if ((this.InitCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.InitCompleted(this, new InitCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks>
///The 'AddFile' method is used to basically put a file on the super 
///         computer. It should be called once to a load a .poy script. Plus 
///         it should be called for each file that the POY script references. 
///         It is the responsibility of the downstream client developer to 
///         generate the POY scripts this places more work in there hands but 
///         also give them great flexibility to do design web apps that can 
///         use POY for anything.
///		
///</remarks>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("supramap/AddFile", RequestNamespace="supramap", ResponseNamespace="supramap", ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped, Use=System.Web.Services.Description.SoapBindingUse.Literal)]
        public string AddFile(int jobId, byte[] fileData, string fileName) {
            object[] results = this.Invoke("AddFile", new object[] {
                        jobId,
                        fileData,
                        fileName});
            return ((string)(results[0]));
        }
        
        public System.IAsyncResult BeginAddFile(int jobId, byte[] fileData, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddFile", new object[] {
                        jobId,
                        fileData,
                        fileName}, callback, asyncState);
        }
        
        public string EndAddFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        public void AddFileAsync(int jobId, byte[] fileData, string fileName) {
            this.AddFileAsync(jobId, fileData, fileName, null);
        }
        
        public void AddFileAsync(int jobId, byte[] fileData, string fileName, object userState) {
            if ((this.AddFileOperationCompleted == null)) {
                this.AddFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddFileCompleted);
            }
            this.InvokeAsync("AddFile", new object[] {
                        jobId,
                        fileData,
                        fileName}, this.AddFileOperationCompleted, userState);
        }
        
        private void OnAddFileCompleted(object arg) {
            if ((this.AddFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddFileCompleted(this, new AddFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks>
///An alternative to the Add File method that uses a simple string as parameter  instead of binary data.
///</remarks>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("supramap/AddTextFile", RequestNamespace="supramap", ResponseNamespace="supramap", ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped, Use=System.Web.Services.Description.SoapBindingUse.Literal)]
        public string AddTextFile(int jobId, string fileData, string fileName) {
            object[] results = this.Invoke("AddTextFile", new object[] {
                        jobId,
                        fileData,
                        fileName});
            return ((string)(results[0]));
        }
        
        public System.IAsyncResult BeginAddTextFile(int jobId, string fileData, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("AddTextFile", new object[] {
                        jobId,
                        fileData,
                        fileName}, callback, asyncState);
        }
        
        public string EndAddTextFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        public void AddTextFileAsync(int jobId, string fileData, string fileName) {
            this.AddTextFileAsync(jobId, fileData, fileName, null);
        }
        
        public void AddTextFileAsync(int jobId, string fileData, string fileName, object userState) {
            if ((this.AddTextFileOperationCompleted == null)) {
                this.AddTextFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnAddTextFileCompleted);
            }
            this.InvokeAsync("AddTextFile", new object[] {
                        jobId,
                        fileData,
                        fileName}, this.AddTextFileOperationCompleted, userState);
        }
        
        private void OnAddTextFileCompleted(object arg) {
            if ((this.AddTextFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.AddTextFileCompleted(this, new AddTextFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks>
///   The 'SubmitPoy' method start a job on the super computer 
///         that start the POY job. When running a job on a super computer 
///         you have to request a what resource you need like how many 
///         processors, how many nodes, how much memory and how long it 
///         will take. If you ask for a lot of resources your job could 
///         get scheduled for a future date instead of running immediately. 
///         So it would not be suitable for  realtime-ish apps. On the other 
///         hand if you request to little resources your job might not finish. 
///         Also we could extend the web service by adding new method that 
///         are similar to this one but only use other back-end Linux tools. 
///         These methods could take advantage of all of the existing infrastructure. 
///</remarks>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("supramap/SubmitPoy", RequestNamespace="supramap", ResponseNamespace="supramap", ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped, Use=System.Web.Services.Description.SoapBindingUse.Literal)]
        public string SubmitPoy(int jobId, int numberOfNodes, int wallTimeHours, int wallTimeMinutes) {
            object[] results = this.Invoke("SubmitPoy", new object[] {
                        jobId,
                        numberOfNodes,
                        wallTimeHours,
                        wallTimeMinutes});
            return ((string)(results[0]));
        }
        
        public System.IAsyncResult BeginSubmitPoy(int jobId, int numberOfNodes, int wallTimeHours, int wallTimeMinutes, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("SubmitPoy", new object[] {
                        jobId,
                        numberOfNodes,
                        wallTimeHours,
                        wallTimeMinutes}, callback, asyncState);
        }
        
        public string EndSubmitPoy(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((string)(results[0]));
        }
        
        public void SubmitPoyAsync(int jobId, int numberOfNodes, int wallTimeHours, int wallTimeMinutes) {
            this.SubmitPoyAsync(jobId, numberOfNodes, wallTimeHours, wallTimeMinutes, null);
        }
        
        public void SubmitPoyAsync(int jobId, int numberOfNodes, int wallTimeHours, int wallTimeMinutes, object userState) {
            if ((this.SubmitPoyOperationCompleted == null)) {
                this.SubmitPoyOperationCompleted = new System.Threading.SendOrPostCallback(this.OnSubmitPoyCompleted);
            }
            this.InvokeAsync("SubmitPoy", new object[] {
                        jobId,
                        numberOfNodes,
                        wallTimeHours,
                        wallTimeMinutes}, this.SubmitPoyOperationCompleted, userState);
        }
        
        private void OnSubmitPoyCompleted(object arg) {
            if ((this.SubmitPoyCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.SubmitPoyCompleted(this, new SubmitPoyCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks>
///  The client must periodically poll the service after it submits its job so it knows when its job is done. 
///        The 'IsDoneYet' method does just that and returns true if the job is done and false if the job is not 
///        done yet. 
///</remarks>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("supramap/IsDoneYet", RequestNamespace="supramap", ResponseNamespace="supramap", ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped, Use=System.Web.Services.Description.SoapBindingUse.Literal)]
        public bool IsDoneYet(int jobId) {
            object[] results = this.Invoke("IsDoneYet", new object[] {
                        jobId});
            return ((bool)(results[0]));
        }
        
        public System.IAsyncResult BeginIsDoneYet(int jobId, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("IsDoneYet", new object[] {
                        jobId}, callback, asyncState);
        }
        
        public bool EndIsDoneYet(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((bool)(results[0]));
        }
        
        public void IsDoneYetAsync(int jobId) {
            this.IsDoneYetAsync(jobId, null);
        }
        
        public void IsDoneYetAsync(int jobId, object userState) {
            if ((this.IsDoneYetOperationCompleted == null)) {
                this.IsDoneYetOperationCompleted = new System.Threading.SendOrPostCallback(this.OnIsDoneYetCompleted);
            }
            this.InvokeAsync("IsDoneYet", new object[] {
                        jobId}, this.IsDoneYetOperationCompleted, userState);
        }
        
        private void OnIsDoneYetCompleted(object arg) {
            if ((this.IsDoneYetCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.IsDoneYetCompleted(this, new IsDoneYetCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
        
        /// <remarks>
///The last method 'GetFile' basically is used to retrieve the output files specified in the POY script. It is called once per file. 
///</remarks>
        [System.Web.Services.Protocols.SoapDocumentMethodAttribute("supramap/GetFile", RequestNamespace="supramap", ResponseNamespace="supramap", ParameterStyle=System.Web.Services.Protocols.SoapParameterStyle.Wrapped, Use=System.Web.Services.Description.SoapBindingUse.Literal)]
        public byte[] GetFile(int jobId, string fileName) {
            object[] results = this.Invoke("GetFile", new object[] {
                        jobId,
                        fileName});
            return ((byte[])(results[0]));
        }
        
        public System.IAsyncResult BeginGetFile(int jobId, string fileName, System.AsyncCallback callback, object asyncState) {
            return this.BeginInvoke("GetFile", new object[] {
                        jobId,
                        fileName}, callback, asyncState);
        }
        
        public byte[] EndGetFile(System.IAsyncResult asyncResult) {
            object[] results = this.EndInvoke(asyncResult);
            return ((byte[])(results[0]));
        }
        
        public void GetFileAsync(int jobId, string fileName) {
            this.GetFileAsync(jobId, fileName, null);
        }
        
        public void GetFileAsync(int jobId, string fileName, object userState) {
            if ((this.GetFileOperationCompleted == null)) {
                this.GetFileOperationCompleted = new System.Threading.SendOrPostCallback(this.OnGetFileCompleted);
            }
            this.InvokeAsync("GetFile", new object[] {
                        jobId,
                        fileName}, this.GetFileOperationCompleted, userState);
        }
        
        private void OnGetFileCompleted(object arg) {
            if ((this.GetFileCompleted != null)) {
                System.Web.Services.Protocols.InvokeCompletedEventArgs invokeArgs = ((System.Web.Services.Protocols.InvokeCompletedEventArgs)(arg));
                this.GetFileCompleted(this, new GetFileCompletedEventArgs(invokeArgs.Results, invokeArgs.Error, invokeArgs.Cancelled, invokeArgs.UserState));
            }
        }
    }
    
    public partial class InitCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal InitCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        public int Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((int)(this.results[0]));
            }
        }
    }
    
    public delegate void InitCompletedEventHandler(object sender, InitCompletedEventArgs args);
    
    public partial class AddFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    public delegate void AddFileCompletedEventHandler(object sender, AddFileCompletedEventArgs args);
    
    public partial class AddTextFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal AddTextFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    public delegate void AddTextFileCompletedEventHandler(object sender, AddTextFileCompletedEventArgs args);
    
    public partial class SubmitPoyCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal SubmitPoyCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        public string Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((string)(this.results[0]));
            }
        }
    }
    
    public delegate void SubmitPoyCompletedEventHandler(object sender, SubmitPoyCompletedEventArgs args);
    
    public partial class IsDoneYetCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal IsDoneYetCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        public bool Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((bool)(this.results[0]));
            }
        }
    }
    
    public delegate void IsDoneYetCompletedEventHandler(object sender, IsDoneYetCompletedEventArgs args);
    
    public partial class GetFileCompletedEventArgs : System.ComponentModel.AsyncCompletedEventArgs {
        
        private object[] results;
        
        internal GetFileCompletedEventArgs(object[] results, System.Exception exception, bool cancelled, object userState) : 
                base(exception, cancelled, userState) {
            this.results = results;
        }
        
        public byte[] Result {
            get {
                this.RaiseExceptionIfNecessary();
                return ((byte[])(this.results[0]));
            }
        }
    }
    
    public delegate void GetFileCompletedEventHandler(object sender, GetFileCompletedEventArgs args);
}
